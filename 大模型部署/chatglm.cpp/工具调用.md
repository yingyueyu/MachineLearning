# 工具调用

[tavily 官网](https://docs.tavily.com/)

[tavily github](https://github.com/tavily-ai/tavily-python)

[DuckDuckGo github](https://github.com/deedy5/duckduckgo_search)

[知心天气](https://www.seniverse.com/)

大模型有自己的工具思维能力，例如: 你告诉大模型，你有一本英汉字典，当你问他翻译问题时，大模型会思考是否调用工具，调用哪个工具来解决问题

## 步骤

调用工具的步骤大致为以下几点

1. 在用户提问前，先告诉大模型有哪些工具可以用
2. 用户提问
3. 大模型思考用什么工具
4. 调用工具得到结果
5. 将调用工具的结果丢给大模型
6. 大模型输出最终结果给用户

大致流程图如下

````
<|system|>
你能够使用以下工具: ...
<|user|>
提出问题
<|assistant|>
思考应该做什么
<|assistant|>
调用工具的名称
```python
tool_call(调用工具的参数)
```
<|observation|>
工具回复的结果，为一个字符串
<|assistant|>
(如果知道最后答案）我知道最后答案了，回答用户的问题
````

## 工具注册器

为了告诉大模型有哪些工具可以用，我们需要以系统身份和他聊天，告诉他如下内容:

```
Answer the following questions as best as you can. You have access to the following tools:
{
    "random_number_generator": {
        # 工具名称
        "name": "random_number_generator",
        # 描述信息
        "description": "Generates a random number x, s.t. range[0] <= x < range[1]",
        # 参数列表
        "params": [
            {
                # 参数名
                "name": "seed",
                # 描述
                "description": "The random seed used by the generator",
                # 参数类型
                "type": "int",
                # 是否必填
                "required": true
            },
            {
                "name": "range",
                "description": "The range of the generated numbers",
                "type": "tuple[int, int]",
                "required": true
            }
        ]
    },
    "get_weather": {
        "name": "get_weather",
        "description": "Get the current weather for `city_name`",
        "params": [
            {
                "name": "city_name",
                "description": "The name of the city to be queried",
                "type": "str",
                "required": true
            }
        ]
    }
}
```

上述工具只是个例子，所以我们的任务就是要获取工具的元数据，那么为了方便获取元数据，我们可以创建一个自己的注册器

```python
from pprint import pformat
from types import GenericAlias
from typing import get_origin, Annotated

# 工具字典
_TOOL_HOOKS = {}
# 元数据字典
_TOOL_DESCRIPTIONS = {}


# 声明一个装饰器函数，接收参数是一个函数
def register_tool(func: callable):
    tool_name = func.__name__
    # inspect 是 python 标准库中的包，用于查询函数元数据
    # inspect.getdoc(func) 获取文档注释
    tool_description = inspect.getdoc(func).strip()
    # inspect.signature(func) 获取函数签名
    python_params = inspect.signature(func).parameters
    tool_params = []
    # python_params 参数字典
    for name, param in python_params.items():
        # param.annotation 参数上的注解
        annotation = param.annotation
        # 检查注解是否为空
        if annotation is inspect.Parameter.empty:
            raise TypeError(f"Parameter `{name}` missing type annotation")
        # 检查泛型的基础类型是否是 Annotated
        if get_origin(annotation) != Annotated:
            raise TypeError(f"Annotation type for `{name}` must be typing.Annotated")

        # 获取参数类型、描述、是否必填
        typ, (description, required) = annotation.__origin__, annotation.__metadata__
        # 检查是否是泛型，并根据条件赋值参数类型
        typ: str = str(typ) if isinstance(typ, GenericAlias) else typ.__name__
        if not isinstance(description, str):
            raise TypeError(f"Description for `{name}` must be a string")
        if not isinstance(required, bool):
            raise TypeError(f"Required for `{name}` must be a bool")

        tool_params.append({
            "name": name,
            "description": description,
            "type": typ,
            "required": required
        })
    tool_def = {
        "name": tool_name,
        "description": tool_description,
        "parameters": tool_params
    }

    print("[registered tool] " + pformat(tool_def))
    _TOOL_HOOKS[tool_name] = func
    _TOOL_DESCRIPTIONS[tool_name] = tool_def

    return func
```

注册器有了，我们尝试注册两个简单工具，如下:

```python
@register_tool
def add(a: Annotated[int, '第一个数', True], b: Annotated[int, '第二个数', True]):
    """加法运算器"""
    return a + b

@register_tool
def sub(a: Annotated[int, '第一个数', True], b: Annotated[int, '第二个数', True]):
    """减法运算器"""
    return a - b
```

这里可以注册一个查询天气的工具，例如[高的开放平台](https://lbs.amap.com/)的[天气API接口](https://lbs.amap.com/api/webservice/guide/api/weatherinfo)

其中还需要用到查询[行政区号的API](https://lbs.amap.com/api/webservice/guide/api/district/)

为了模型能够调用工具，我们创建一个调用工具的函数和获取元数据的方法

```python
def dispatch_tool(tool_name: str, tool_params: dict) -> str:
    if tool_name not in _TOOL_HOOKS:
        return f"Tool `{tool_name}` not found. Please use a provided tool."
    tool_call = _TOOL_HOOKS[tool_name]
    try:
        ret = tool_call(**tool_params)
    except:
        ret = traceback.format_exc()
    return str(ret)


def get_tools() -> dict:
    return deepcopy(_TOOL_DESCRIPTIONS)
```

至此工具注册器就算写好了

## 按步骤实现工具调用

1. 在用户提问前，先告诉大模型有哪些工具可以用
2. 用户提问
3. 大模型思考用什么工具
4. 调用工具得到结果
5. 将调用工具的结果丢给大模型
6. 大模型输出最终结果给用户

假设我们已经完成了工具注册

也已经创建好了模型，接着执行以下步骤

### 1. 告诉模型有哪些工具

获取元数据，并添加系统信息:

```python
from 工具注册器 import register_tool, get_tools, dispatch_tool

tools = get_tools()
tools = list(tools.values())

messages = [
    ChatMessage(role="system",
                content=f"Answer the following questions as best as you can. You have access to the following tools: \n{str(tools)}")
]
```

### 2. 用户提问

```python
messages.append(ChatMessage(role="user", content="请问 12 + 4 等于多少？"))
```

### 3. 大模型思考用什么工具

此处需要调用大模型的聊天接口

```python
result = model.chat(messages)
# 获取返回结果中要调用的工具名称和参数
tool_name = result.tool_calls[0].function.name
arguments = result.tool_calls[0].function.arguments
# 添加模型的思考过程
messages.append(result)
```

若大模型返回结果中包含 `tool_calls` 则说明他想要调用工具，此时通过上述代码获取要调用的工具名和参数

值得注意的是参数 `arguments` 大模型已经把他做成了函数调用的格式，例如:

```python
tool_call(a=12, b=4)
```

### 4. 调用工具

因为 `arguments` 参数已经是函数表达式了，所以我们只需要创建一个名为 `tool_call` 的函数，并调用它就可以了

```python
def tool_call(**kwargs):
    return dispatch_tool(tool_name, kwargs)
```

此处的 `tool_name` 为 `add`；`kwargs` 是传入的关键字参数

直接使用 `eval` 函数调用 `tool_call`

```python
tool_result = eval(arguments)
```

调用完后，需要以 `observation` 角色身份添加信息

```python
messages.append(ChatMessage(role='observation', content=tool_result))
```

### 5. 调用工具的结果丢给大模型

```python
result = model.chat(messages)
```

### 6．大模型输出最终结果给用户

```python
print(result)
```