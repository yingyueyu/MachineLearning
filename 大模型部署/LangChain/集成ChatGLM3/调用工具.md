# 调用工具

```python
from langchain_core.messages import HumanMessage, SystemMessage
from langchain_core.tools import BaseTool

from ChatGLM3 import get_model
from tools.weather import get_weather


tool_call_id = 0
tools = {}
tools[get_weather.name] = get_weather

messages = [
    # 各类消息的作用: https://python.langchain.com/v0.2/docs/how_to/custom_chat_model/#messages
    HumanMessage(content='今天重庆(city_code: 500000)天气怎么样？')
]

model = get_model()
# 绑定工具
model = model.bind_tools(list(tools.values()))
message = model.invoke(messages)
# 保存消息列表
messages.append(message)
# print(message)
# 长度大于零说明需要调用工具
if len(message.tool_calls) > 0:
    tool_result = {}
    for tool in message.tool_calls:
        tool_name = tool['name']
        _tool_call = tools[tool_name]
        # 获取工具函数
        tool_call = lambda **kwargs: _tool_call.invoke(input=kwargs) if isinstance(_tool_call, BaseTool) else _tool_call.func
        result = tool_call(**tool['args'])
        print(result)
        tool_result[tool_name] = result

    # 将工具结果加入消息列表
    messages.append(
        SystemMessage(
            content=f'已收到工具调用的结果，对应 tool_name 和调用结果如下: \n{tool_result}。\n请根据工具结果回答用户的问题。',
            artifact={},
            tool_call_id=str(tool_call_id)
        )
    )
    tool_call_id += 1
    # 将工具结果告诉模型，并让模型整理输出
    message = model.invoke(messages)
    print(message)
    messages.append(message)
```

## 重点解析:

### 1. 绑定工具 bind_tools

此步很重要，这个步骤是告诉模型，我们有哪些工具可以提供他调用

不执行此步，模型将失去工具调用能力

```python
model = model.bind_tools(list(tools.values()))
```

### 2. 获取工具函数

获取工具函数时，你拿到的是 `bind_tools` 后的工具，那么它可能是 `BaseTool` 类型，也可能是 `StructuredTool` 类型

当不同类型时，要用不同方法调用函数，如下:

- `BaseTool`: `tool.invoke(**参数字典放这里)`
- `StructuredTool`: `tool.func(**参数字典放这里)`

所有我们代码中进行判断

```python
# 若为 BaseTool，我们返回一个盗用 invoke 的 lambda 表达式
# 若不是 BaseTool 我们返回 func 函数
tool_call = lambda **kwargs: _tool_call.invoke(input=kwargs) if isinstance(_tool_call, BaseTool) else _tool_call.func
# 调用函数并传参
result = tool_call(**tool['args'])
```

### 3. 获取工具结果并回调模型

工具结果获取到后，我们需要在消息列表中添加信息来告诉模型结果

```python
messages.append(
    SystemMessage(
        content=f'已收到工具调用的结果，对应 tool_name 和调用结果如下: \n{tool_result}。\n请根据工具结果回答用户的问题。',
        artifact={},
        tool_call_id=str(tool_call_id)
    )
)
```

==**注意:** 本来对于 `chatglm` 工具返回值的 `role` 应该等于 `observation` 才对，但是我们的 API 服务器不支持 `observation` 这个 `role`，所以此处换成了 `system` 这个角色==

然后再次调用模型，让模型总结输出

```python
message = model.invoke(messages)
```