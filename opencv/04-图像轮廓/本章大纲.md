[TOC]



# 图像轮廓

图像的边缘检测虽然可以检测出边缘，但边缘是不连续的，检测到的边缘并不是一个整体，图像轮廓是指将边缘连接起来形成的一个整体，可以用于后续的计算。



`Opencv`提供了查找图像轮廓的函数`cv2.findContours()`，该函数能够查找图像内的轮廓信息，而函数`cv2.drawContours()`能够将轮廓绘制出来



图像的轮廓是图像中非常重要的一个特征信息，通过对图像轮廓的操作，能够获取目标的大小、位置、方向等信息。



## 轮廓特征

轮廓特征是指由轮廓形状和结构衍生出来的一些特征参数。这些特征参数可以用于图像识别、目标检测和形状分析等应用中：



常见的轮廓特征：

1. 面积：轮廓所包围的区域的面积
2. 周长：轮廓的周长，即轮廓线的长度
3. 弧长：轮廓线的弧长，即轮廓的长度
4. 轮廓矩：轮廓的几何矩，用于描述轮廓的形状
5. 轮廓中心：轮廓所包围区域的重心坐标
6. 外接矩形：能够完全包围轮廓的矩形
7. 最小外接矩形：能够紧密包围轮廓的矩形，且角度与轮廓的方向一致
8. 外接圆：能够完全包围轮廓的圆
9. 最小外接圆：能够紧密包围轮廓的圆
10. 椭圆拟合：能够最好地拟合轮廓地椭圆
11. 凸包：能够包围轮廓的最小凸多边形
12. 轮廓层级：描述轮廓的嵌套关系



这些轮廓特征可以通过OpenCV库的`cv2.contourArea()、cv2.arcLength()、cv2.moments()、cv2.boundingRect()、cv2.minAreaRect()、cv2.minEnclosingCircle()、cv2.fitEllipse()、cv2.convexHull()`等函数来计算和获取，下面主要介绍一些常用的特征。




## 图像轮廓特征查找

函数`cv2.findContours()`的语法格式为：

```python
contours,hierarchy = cv2.findContours(image,mode,method)
```

上述公式中：

+ contours:  返回的轮廓（主要是若干个点的坐标）
+ hierarchy: 图像的`拓扑信息`（轮廓层次）
+ image: 原始图像（此处为8为单通道图像，非零像素处理为1，零值不变）
+ mode：轮廓的检索模式
+ method：轮廓的近似方法

### contours（轮廓）

该返回值返回的是一组轮廓信息，每个轮廓都是由若干个点所构成的。

例如：countours[i] 是第i个轮廓（下标从0开始）,contours\[i]\[j] 是第i个轮廓内的第j个点



### hierarchy（层次信息）

图像内的轮廓可能位于不同的位置。比如，一个轮廓在另一个轮廓的内部。这种情况下，我们将外部的轮廓称为父轮廓，内部的轮廓称为子轮廓。

每个hierarchy\[i] 对应4个元素，其形式为：

```
[Next,Previous,First_Child,Parent]
```

+ Next： 后一个轮廓的索引编号
+ Previous：前一个轮廓的索引编号
+ First_Child：第1个子轮廓的索引编号
+ Parent：父轮廓的索引编号

轮廓的层次结构是由参数mode决定的。也即是不同mode，会得到不同的轮廓编号





### 参数 mode

参数mode决定了轮廓的提取方式，具体有如下4种：

+ `cv2.RETR_EXTERNAL`:只检测外轮廓
+ `cv2.RETR_LIST`:对检测到的轮廓不建立等级关系
+ `cv2.RETR_CCOMP`:检索所有轮廓并将他们组织成两级层次结构。上面的一层为外边界，下面一层为内孔的边界。如果内孔内还有一个连通物体，那么这个物体的边界仍然位于顶层。
+ `cv2.RETR_TREE`: 建立一个等级树结构的轮廓





### 参数method

参数method决定了如何表达轮廓：

+ `cv2.CHAIN_APPROX_NONE`：存储所有的轮廓点，相邻两个点的像素位置差不超过 1， 即 `max(abs(x1-x2)，abs(y2-y1))=1`。
+ `cv2.CHAIN_APPROX_SIMPLE`：压缩水平方向、垂直方向、对角线方向的元素，只保 留该方向的终点坐标。例如，在极端的情况下，一个矩形只需要用 4 个点来保存轮廓信息。
+ `cv2.CHAIN_APPROX_TC89_L1`：使用 teh-Chinl chain 近似算法的一种风格。
+ `cv2.CHAIN_APPROX_TC89_KCOS`：使用 teh-Chinl chain 近似算法的一种风格 



## 绘制图像轮廓



### 绘制图像轮廓：drawContours函数

在 `OpenCV` 中，可以使用函数 `cv2.drawContours() `绘制图像轮廓。该函数的语法格式是：

```python
image=cv2.drawContours(image, contours, contourIdx, color[, thickness[,lineType[, hierarchy[, maxLevel[, offset]]]]] )
```



函数 cv2.drawContours()的参数 image 和返回值 image，在函数运算后的值是相同的。因此， 也可以将函数 cv2.drawContours()写为没有返回值的形式。

**该函数有如下参数：**

+ image：待绘制轮廓的图像。需要注意，函数 cv2.drawContours()会在图像 image 上直接 绘制轮廓。也就是说，在函数执行完以后，image 不再是原始图像，而是包含了轮廓的 图像。因此，如果图像 image 还有其他用途的话，则需要预先复制一份，将该副本图像 传递给函数` cv2.drawContours()`使用。
+ contours：需要绘制的轮廓。该参数的类型与函数 `cv2.findContours()`的输出 contours 相 同，都是 list 类型。
+ contourIdx：需要绘制的边缘索引，告诉函数 cv2.drawContours()要绘制某一条轮廓还是 全部轮廓。如果该参数是一个整数或者为零，则表示绘制对应索引号的轮廓；如果该值 为负数（通常为“-1”），则表示绘制全部轮廓。
+ color：绘制的颜色，用 BGR 格式表示。
+ thickness：可选参数，表示绘制轮廓时所用画笔的粗细。如将该值设置为“-1”，则表示要绘制实心轮廓。
+ lineType：可选参数，表示绘制轮廓时所用的线型。关于参数 color、thickness 和 lineType 的具体介绍，可参考第 19 章。
+ hierarchy：对应函数 cv2.findContours() 所输出的层次信息。
+ maxLevel：控制所绘制的轮廓层次的深度。如果值为 0，表示仅仅绘制第 0 层的轮廓； 如果值为其他的非零正数，表示绘制最高层及以下的相同数量层级的轮廓。



```python
"""
查找并绘制轮廓
"""
import cv2
 
src = cv2.imread("car.png")
 
# copy image，用来画图
src_copy1 = src.copy()
src_copy2 = src.copy()
src_copy3 = src.copy()
src_copy4 = src.copy()
src_copy5 = src.copy()
 
img_gray = cv2.cvtColor(src, cv2.COLOR_BGRA2GRAY)  # 灰度化
img_edge = cv2.Canny(img_gray, 60, 128)  # canny 算法，对图像进行边缘处理
 
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 10))  # 10*10的矩形对图像进行遍历
img_dil = cv2.dilate(img_edge, kernel=kernel)  # 膨胀操作
 
# 查找轮廓（cv2.RETR_TREE），建立一个等级树结构的轮廓。
# image, contours, hierarchy = cv2.findContours(src, mode, method)
image, contours, hierarchy = cv2.findContours(img_dil, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
for i, c in enumerate(contours):
    print(i, "\n", c)
 
    # cv2.boundingRect: 该函数计算并返回指定点集的最小垂直边界矩形。
    # 左上角坐标、矩形的宽、矩形的高
    x, y, w, h = cv2.boundingRect(c)
    print(x, y, w, h)
 
    # 绘制轮廓
    # 参数：图像、需要绘制的轮廓、需要绘制的边缘索引、颜色、线条的宽度
    # 需要绘制的边缘索引: 如果指定一个值，则绘制一个轮廓，如果该值为负数(通常为 -1)，则表示绘制所有轮廓
    cv2.drawContours(src, [contours[i]], -1,  (255, 0, 0), -1)
 
    # 注意：contours[i] == c，此处如果不加[]，则绘制的轮廓不连续
    cv2.drawContours(src_copy4, c, -1, (255, 0, 0), 4)
 
    # 线条的宽度要是设置成 -1，则表示绘制实心轮廓
    cv2.drawContours(src_copy5, [c], -1, (255, 0, 0), -1)
 
    # 绘制最小外接矩形
    # 参数：图像、左上角坐标、右下角坐标、颜色、线条的宽度
    cv2.rectangle(src_copy1, (x, y), (x + w, y + h), (255, 0, 0), 4)
print(hierarchy)
 
# 查找轮廓（cv2.RETR_EXTERNAL），只查找外轮廓。
image, contours, hierarchy = cv2.findContours(img_dil, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
for i, c in enumerate(contours):
    print(i, "\n", c)
    # cv2.boundingRect: 该函数计算并返回指定点集的最小垂直边界矩形。
    # 左上角坐标、矩形的宽、矩形的高
    x, y, w, h = cv2.boundingRect(c)
    print(x, y, w, h)
    cv2.drawContours(src_copy2, contours[i], -1,  (255, 0, 0), 10)
    cv2.rectangle(src_copy3, (x, y), (x + w, y + h), (255, 0, 0), 4)
print(hierarchy)
 
cv2.imshow('image', img_dil)
cv2.imshow('src', src)
cv2.imshow('src_copy1', src_copy1)
cv2.imshow('src_copy2', src_copy2)
cv2.imshow('src_copy3', src_copy3)
cv2.imshow('src_copy4', src_copy4)
cv2.imshow('src_copy5', src_copy5)
cv2.waitKey(0)
cv2.destroyAllWindows()
```







## 凸包特征轮廓检测



在计算机视觉中，凸包(Convex Hull)是指一个包围一组点的最小凸多边形。凸多边形是一个所有内角均小于180°的多边形。凸包与轮廓近似相似，但不同，只是有些情况下结果是一致的。Opencv中提供了`cv2.convexHull()`函数来计算给定点集的凸包，同时检测一个曲线是否具有凸性缺陷并能纠正缺陷。一般来说。凸性曲线总是凸出来或至少是平的。如果有地方凹下去了，就叫做凸性缺陷。



关于`cv2.convexHull()`函数如下：

```python
hull = cv2.convexHull(points,clockwise,returnPoints)
```



其中：

+ points是一个包含点集的数组
+ clockwise是一个布尔值，永固指定凸包的顺序，如果为True，则返回的凸包按顺时针方向排序；如果为False，则返回的凸包按逆时针方向排序；
+ returnPoints是一个布尔值，用于指定返回的凸包是点的坐标，还是索引，默认为True



